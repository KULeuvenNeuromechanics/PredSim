function [MuscleData] = muscleAnalysisAPI(S,osim_path,model_info,varargin)
% --------------------------------------------------------------------------
% muscleAnalysisAPI
%   Analyse the musculoskeletal geometry of the given osim model.
% 
% INPUT:
%   - S -
%   * setting structure S
%
%   - osim_path -
%   * path to the OpenSim model file (.osim)
% 
%   - model_info -
%   * structure with all the model information based on the OpenSim model
%
%   - Qs - (Optional input, for testing purpose)
%   * Known array with coordinate values used to perform muscle analysis.
%   When omitted, a random array is generated by "PreProcessing\generate_dummy_motion"
%
%   - analyse_ligaments (Optional input)-
%   * Pass argument 'ligaments' to analyse ligaments instead of
%   muscle-tendon paths
%
% OUTPUT:
%   - MuscleData -
%   * structure with joint angles and according muscle-tendon lengths and
%   momentarms (input to PolynomialFit.m)
%
% Original author: Lars D'Hondt
% Original date: 5/April/2022
% --------------------------------------------------------------------------



% number of coordinates
n_coord = model_info.ExtFunIO.jointi.nq.all;
% coordinate names
coord_names = model_info.ExtFunIO.coord_names.all;

% names of muscles
muscle_names = model_info.muscle_info.muscle_names;
% number of muscles
n_muscle = model_info.muscle_info.NMuscle;
% get senseble muscle-coordinate combinations to evaluate
muscle_spanning_joint_info = model_info.muscle_info.muscle_spanning_joint_info;


idx_argin_lig = find(cellfun(@(st)(isa(st,'char')||isa(st,'string')),varargin)...
    & strcmp(varargin,'ligaments'));
if any(idx_argin_lig)
    muscle_names = model_info.ligament_info.ligament_names;
    n_muscle = model_info.ligament_info.NLigament;
    muscle_spanning_joint_info = model_info.ligament_info.ligament_spanning_joint_info;
    ligaments_bool = 1;
    varargin = varargin(~idx_argin_lig);
else
    ligaments_bool = 0;
end

if length(varargin)>=1
    argin3 = varargin{1};

    if size(argin3,1) == 1 && size(argin3,2) == 1
        % if it's 1 element, it's the number of data points
        n_data_points = argin3;
    else
        % else, it's the entire dummy motion
        Qs = argin3;
        % number of data points
        n_data_points = size(Qs,1);
    end
else
    % number of data points
    n_data_points = S.misc.msk_geom_n_samples;
    % get dummy motion
    Qs = generate_dummy_motion(S,model_info,n_data_points);
end

%% Initialise model
import org.opensim.modeling.*;
model = Model(osim_path);
s = model.initSystem;
% Get state vector
state_vars = model.getStateVariableValues(s);
% Get set of muscles and other forces
if ligaments_bool
    force_set = model.getForceSet();
else
    force_set = model.getMuscles();
end
coord_set = model.getCoordinateSet;

%% Evaluate muscle-tendon unit lenght and moment arms
% Initialise matrices for results
lMT = zeros(n_data_points,n_muscle);
dM = zeros(n_data_points,n_muscle,n_coord);
Qs2 = nan(size(Qs));

% names of states corresponding to coordinate position values
for i=1:n_coord
    q_state_names{i} = coord_set.get(coord_names{i}).getStateVariableNames().get(0);
    qdot_state_names{i} = coord_set.get(coord_names{i}).getStateVariableNames().get(1);
end

% Loop through dummy states
for j=1:n_data_points

    % Set each coordinate value
    for i=1:n_coord
        if ~isnan(Qs(j,i))
            model.setStateVariableValue(s,q_state_names{i},Qs(j,i));
        end
    end
    model.realizePosition(s);
    model.assemble(s)

    % Loop over muscles
    for m=1:n_muscle
        muscle_m = force_set.get(muscle_names{m});
        if ligaments_bool
            muscle_m = Ligament.safeDownCast(muscle_m);
        end
        % Get MTU length
        lMT(j,m) = muscle_m.getLength(s);
    end

    % Get moment arm
    if ligaments_bool
        for m=1:n_muscle
            muscle_m = Ligament.safeDownCast(force_set.get(muscle_names{m}));
            for i=find(muscle_spanning_joint_info(m,:)==1)
                dM(j,m,i) = muscle_m.computeMomentArm(s,coord_set.get(coord_names{i}));
            end
        end

    else % muscle
        for i=1:n_coord
            % The moment arm is defined as -dl/dq.
            % By settings the velocity of coordinate i to -1 and all other
            % velocities to 0, the moment arm can be calculated as
            % ldot = dl/dq * qdot.
            % This is ~3x faster than using computeMomentArm, and does give the
            % desired moment arms when the model has active constraints.
            model.setStateVariableValue(s,qdot_state_names{i},-1);
            model.realizeVelocity(s)
            for m=find(muscle_spanning_joint_info(:,i)==1)'
                muscle_m = force_set.get(muscle_names{m});
                dM(j,m,i) = muscle_m.getLengtheningSpeed(s);
            end
            model.setStateVariableValue(s,qdot_state_names{i},0);
        end
    end

    % Read coordinate values, in case they were changed by assembling the model
    for i=1:n_coord
        Qs2(j,i) = model.getStateVariableValue(s,q_state_names{i});
    end
end


%% Store analysis results
% structure and fieldnames of MuscleData are to be consistent with PolynomialFit.m

% coordinate names
MuscleData.dof_names = model_info.ExtFunIO.coord_names.all;
% muscle names
MuscleData.muscle_names = muscle_names;
% joint angles training data
MuscleData.q0 = Qs;
MuscleData.q = Qs2;
% muscle-tendon lengths
MuscleData.lMT = lMT;
% moment arms
MuscleData.dM = dM;







